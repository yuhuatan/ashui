Ansible学习笔记

ansible特性：
不用agent
幂等性：以结果为导向，多次执行结果不变。
执行某个task时一台主机执行错误，这个task会回滚。


* 主机清单(Inventory)
没有在主机清单中的主机不能被ansible管理
主机清单中可以用IP地址或者主机名标识主机，连续的IP地址或者主机名可以用连字符表示（比如：node_[a:z])，主机后面可以定义变量
可以设置主机组，组还可以嵌套组（比如：[Group1:children] ）


主机清单几种格式：
IP  [ansible_port=22]  [ansible_user=root]  [ansible_ssh_pass=123456]		#直接登记IP地址，后面可以加上参数，
                                                                         这里的ansible_port表示被管主机的ssh端口号，
                                                                         ansible_user表示通过指定用户去连ssh，
                                                                         ansible_ssh_pass表示指定用户的密码，还可以指定其他变量。

HOSTNAME  ansible_host=IP  [ansible_port=22]  [ansible_user=root]  [ansible_ssh_pass] 	#也可通过名称管理主机，
                                                                                         通过ansible_host指定主机的ip地址，其他参数可选。

[group1]
10.0.0.[1:100]


ansible两种使用方式：
ad-hoc：使用ansible命令执行一次性管理操作
		-m		#指定模块
		-a		#指定模块的参数
		-i		#指定主机清单文件
	
playbook


* 模块(modules):
ansible-doc  -l			#列出所有的模块
ansible-doc  -s  MODULE_NAME		#查看模块的详细用法


* 常用模块使用：

	必须参数：

	其他参数：

	示例：


1，fetch		#从远程主机拉取文件到本地(ansible管理机)
	必须参数：
		src		#原文件地址
		dest		#存放到本地的路径
	其他参数：

	示例：
		ansible 10.0.0.2 -m fetch -a "src=/etc/fstab dest=/root/"		#

2，copy			#从本地拷贝文件到远程主机
	必须参数：
		dest		#存放到目标主机什么路径下。如果用content指定文件内容，这里不能是目录，必须是文件名。
		src / content
			src		#需要拷贝的文件
			content	#如果要拷贝的文件不存在，可以用content指定文件的内容。这两个参数必选一。
	其他参数：
		force		#远程主机有同名文件，但内容不同时是否覆盖。yes表示覆盖，no表示不覆盖，默认为yes。
		backup		#远程主机有同名文件，但内容不同时是否备份。yes表示备份，no表示不备份。
		owner		#指定文件拷贝到远程主机后的属主，远程主机必须有这个用户，否则会报错。
		group		#同上，只不过这里是属组
		mode		#指定文件拷贝到远程主机后的权限，可以使用mode=0644，或者mode=u+x（属主加执行权限）这种
		

	示例：
		ansible GROUP1 -m copy -a 'content="aaa\nbbb\n" dest=/etc/test.conf’		

3，file			#创建/删除文件，修改文件权限
	必须参数：
		path			#要操作的文件或者目录，老版本使用dest或者name。
	其他参数：
		state		#这个参数的值为directory时path表示的是目录，值为touch时表示创建一个文件而不是目录，
             值为link时表示创建一个软链接，值为hard时表示硬链接，值为absent时表示删除。
		src			#当state为link或者hard时，src用来指定链接的源文件。
		force		#当state=link，配合force强制创建链接文件，当force=yes创建链接文件有几种情况：
             一，源文件不存在时也会创建link文件；
             二，存在与链接文件同名(目录也一样)的文件，则同名的文件会被删除，强制创建链接文件；
             三，存在与链接文件同名(目录也一样)的文件，同时链接文件指向的源文件不存在，也会删除同名文件，创建链接文件。
		owner		#指定被操作文件的属主，远程主机必须存在该用户，否则报错。
		group		#同上，只是这里改为属组
		mode		#指定被操作文件的权限，可以使用mode=0644。
		recurse		#当操作的文件为目录时，recurse=yes，可以递归修改目录中文件的属性。
	示例：
		ansible GROUP1 -m file -a "path=/etc/test state=directory owner=root group=root recurse=yes"

4，blockinfile			#在指定文件中插入一段文本，这段文本是被标记的，可以删除或修改这段文本
	必须参数：
		path			#指定要操作的文件
		block		#指定要插入的文本，另一个参数content也一样
		marker		#在文件中插入一段文本，ansible会给这段文本添加两个标记，一个开始标记（# BEGIN ANSIBLE MANAGED BLOCK），
               一个结束标记（# END ANSIBLE MANAGED BLOCK），而maker参数可以自定义标记，比如marker=#{mark}test，
               这样设置后，开始标记就会变成# BEGIN test，结束标记就会变成# END test。我可以在文件中插入多段文本，分别定义不同的标记。
		state		#值为present时表示插入或者修改指定标记的文本，值为absent时表示删除指定标记的文本。默认是present
		insertafter	#在指定行后面插入文本，默认是在文件末尾插入。这里可以通过正则表达式指定行，如果有多行匹配，则在最后匹配的行后面插入。
		insertbefore	#在指定行前面插入文本，也可以使用正则表达式，用法跟上面一样。值为BOF表示在文件开头插入。
		backup		#在修改文件前是否备份
		create		#当要操作的文件不存在时，是否创建。
	其他参数：

	示例：
		ansible GROUP1 -m blockinfile -a 'path=/testdir/rc.local block="####blockinfile test####"  marker="#{mark} test reg" insertafter="^#!/bin/bash" '		#在正则表达式后面插入一段文本

5，lineinfile				#在指定文本中添加/删除/替换某一行。
	必须参数：
		path			#指定要操作的文件

	其他参数：
		line			#指定文本内容
		regexp		#使用正则表达式匹配行，替换时如果有多行匹配则只有最后匹配的行被替换，删除时所有匹配到的行都会被删除。
		state		#要删除对应的文本时，state的值要设置为absent，默认为present。
		backrefs		#用正则表达式进行文本替换时，如果backrefs设置为yes，则line可以引用regexp中的分组。backrefs默认值为no，
                 默认情况下，如果正则表达式没有匹配到行则line中的内容会添加到文件尾部。
                 如果backrefs设置为yes，则regexp没有匹配到行的情况下不会添加line中的内容到文件，即不会修改文件。
		insertafter	#将文本插入到指定行之后，这里的指定行可以是正则表达式或者EOF，EOF表示文件末尾，
                 如果insertafter是正则表达式则表示插入文本到匹配的行，如果没有匹配到行则插入到文末。当使用backrefs时，此参数会被忽略。
		insertbefore	#将文本插入到文件的指定行之前，值可以为正则表达式或者BOF，BOF表示文件开头。
                   如果正则没有匹配到任何行，则插入到文件末尾，当使用backrefs参数时，此参数会被忽略。
		backup		#修改文件前是否对文件进行备份。
		create		#要操作的文件不存在时是否创建该文件。
	示例：
		ansible GROUP1 -m lineinfile -a 'path=/root/test regexp="^line" line="test text" backrefs=yes '		#替换以line开头的行，如果有多行匹配则只替换最后匹配的那行，如果没有匹配到任何一行则不对文件进行任何操作。
		ansible GROUP1 -m lineinfile -a 'path=/testdir/test regexp="(H.{4}).*(H.{4})" line="\2" backrefs=yes'	#前面的regexp分了两组，这里表示用第二组替换整个正则表达式匹配到的内容。

6，find					#查找文件
	必须参数：
		paths		#指定在哪个目录查找文件，可以指定多个路径，路径间以逗号隔开，此参数有path、name这两个别名。

	其他参数：
		recurse		#默认只会在指定的目录查找文件，不会递归到子目录查找，recurse=yes表示递归到子目录进行查找
		hidden		#默认情况下，隐藏文件会被忽略，当hidden=yes表示隐藏文件也会查找。
		file_type		#默认情况下只会查找文件，不会查找目录、软连接这类，file_type指定查找文件的类型，有4个值可选：any、directory、file、link。
		patterns		#指定查找文件的名称，可以使用通配符或者正则表达式，默认使用通配符，如果想使用python正则表达式则需将use_regex参数设置为yes。
		use_regex	#值为yes表示使用正则表达式解析patterns中的表达式，默认使用glob通配符解析。
		contains		#使用此参数可以根据文件内容查找文件，此参数的值为一个正则表达式，find模块会根据正则表达式去匹配文件的内容。
		age			#根据时间查找文件，默认以mtime查找，age=3d表示查找mtime在三天以前的文件，age=-3d表示mtime在三天以内的文件，可以使用的单位有s（秒）、m（分）、h（时）、d（天）、w(星期)。
		age_stamp	#指定时间种类，有三种值可选atime、ctime，mtime
		size			#根据文件大小查找，size=3m表示查找大于3MB的文件，size=-3m表示文件大小在3MB以内的，可以使用的单位有t、g、m、k，b。
		get_checksum		#找到文件时同时计算出该文件的sha1校验码。
	示例：
		ansible GROUP1 -m find -a 'paths=/root contains=".*abc.*" '		#查找/root下包含文本“abc”的文件，忽略隐藏文件，不递归查找。
		ansible GROUP1 -m find -a 'paths=/root patterns=".*\.sh" use_regex=yes file_type=any hidden=yes'	#查找/root目录下以.sh结尾的文件，包含任何类型的文件，包括隐藏文件，这里使用正则表达式。
		ansible GROUP1 -m find -a "paths=/root patterns=*.sh get_checksum=yes  hidden=yes recurse=yes"

7，replace				#根据正则表达替换文件中的字符串，文件中所有匹配到的字符串都会被替换。
	必须参数：
		path			#指定要操作的文件，有dest、destfile、name这些别名
		regexp		#指定匹配的正则表达式，文件中与正则表达式匹配的字符串会被替换。

	其他参数：
		replace		#指定最终要替换成的字符串。
		backup		#修改前是否备份文件。
	示例：
		ansible GROUP1 -m replace -a 'path=/root/test regexp="ASM" replace=asm backup=yes'

8，command			#在远程主机上执行命令，使用command模块执行命令时不会经过shell处理，所以命令中包含”<“, “>”, “|”, “;” 和 “&”这些重定向、管道符等操作时，
                 这些符号会失效，这时可以参考shell模块。远程主机为windows时需要使用win_command模块。

	必须参数：
		命令			#在远程主机上要执行的命令，比如ls、rm等
	其他参数：
		chdir		#执行命令前切换到chdir指定的目录
		creates		#指定一个文件（可以使用通配符），如果指定的文件存在则不执行命令
		removes		##指定一个文件（可以使用通配符），如果指定的文件不存在则不执行命令
	示例：
		ansible test70 -m command -a "chdir=/testdir ls"

9，shell				#在远程主机上执行命令，跟command不同，这里的命令是通过shell进行处理，支持管道，重定向等特殊符号。
	必须参数：
		命令			#指定在远程主机上执行的命令
	其他参数：
		chdir		#参考command
		creates		#参考command
		removes		#参考command
		executable	#指定shell执行命令，默认的shell是/bin/sh，可以指定shell，要使用绝对路径
	示例：
		ansible GROUP1 -m shell -a "chdir=/testdir echo test > test"

10，script			#在远程主机执行ansible主机上的脚本，不用将脚本拷贝到远程主机再执行。
	必须参数：
		要在远程执行的脚本		#

	其他参数：
		chdir				#先切换到指定目录再执行脚本
		creates				#参考command
		removes				#参考command
	示例：
		ansible GROUP1 -m script -a "creates=/opt/testfile /testdir/atest.sh"

11，cron				#管理远程主机的定时任务
	时间参数： 当时间参数不指定时表示 “* * * * *” 表示每分钟都执行
		minute			#指定分钟，默认为“*”
		hour				#指定小时
		day				#指定日期
		month			#指定月份
		weekday			#指定周几
		special_time		#指定一些特殊时刻，reboot（重启时），yearly（每年），annually（同yearlly），monthly（每月），weekly（每周），daily（每天），hourly（每时）
	其他参数：
		user				#指定此定时任务属于哪个用户，默认是root用户
		job				#指定需要执行的命令或脚本
		name			#指定定时任务的名称，方便修改/注释/删除操作。
		state			#state=absent时表示删除指定的定时任务。
		disable			#注释指定的定时任务，注释时设定的时间必须与设置的一致，否则任务的时间会被修改然后注释
		backup			#修改前是否先备份，可以通过执行返回的backup_file看到备份文件的路径。修改定时任务时最好备份一下。
	示例：
		ansible GROUP1 -m cron -a " name='test special time' special_time=hourly job='echo test' backup=yes "

12，service				#管理远程主机上的服务（这些服务能被service，systemctl管理）
	参数：
		name			#指定服务的名称
		state			#指定服务的期望状态，可选的状态有started、stopped、restarted、reloaded。
		enabled			#指定是否开机启动，yes表示开机启动，no表示开机不启动。

	示例：
		ansible GROUP1 -m service -a "name=nginx state=stopped"

13，user					#管理远程主机上的用户，创建/修改/删除用户，创建密钥等。
	必须参数：
		name			#指定要操作的用户名，可以使用别名user。
	其他参数：
		group			#指定用户所在的组
		groups			#指定用户所在的附加组。
		append			#跟groups配合使用，值为yes时表示追加groups指定的组为用户的附加组。默认值为no，表示用groups的值覆盖原来的附加组。
		shell				#指定用户的默认shell
		uid				#指定用户的uid
		expires			#设置用户的过期时间。比如expires=1546185600，这是时间戳。设置成功后会换算成天数。
		comment			#指定用户的注释信息
		state			#指定用户是否要存在，可选值有present、absent，默认值为present表示用户需要存在，absent表示删除该用户。
		remove			#删除用户时是否删除家目录等信息，值为yes时表示删除家目录等信息，默认值为no
		password			#设定用户密码，这里不是明文密码，而是加密过的密码，通过python得到加密后的密码。import crypt; crypt.crypt(‘123456’)
		update_password	#值为always时，password的值与原密码不一致则更新密码。值为on_create时当password的值与原密码不一致则不更新密码，新建用户时除外。
		generate_ssh_key	#是否生成密钥对，默认值为no表示不生成。yes表示生成，如果已存在则不生成。
	示例：
		ansible GROUP1 -m user -a 'name=abc state=absent remove=yes'

14，group				#管理远程主机上的组
	必须参数：
		name			#指定要操作的组名称
	其他参数：
		state			#指定组的期望状态，可选值有present，absent。absent表示删除组。
		gid				#组id

15，yum_repository			#管理远程主机的yum仓库
	必须参数：
		name			#指定要操作的仓库名，唯一标识仓库。
	其他参数：
		baseurl			#yum仓库的baseurl
		description		#设置仓库的注释信息，也就是”.repo”配置文件中每个仓库对应的”name字段”对应的内容。
		file				#设置仓库配置文件的文件名
		enable			#是否启用此仓库，默认值为yes表示启用，no表示不启用。
		gpgcheck			#是否开启rpm包验证功能，默认值为no表示不验证，yes表示开启验证。
		gpgcakey			#当gpgcheck值为yes时，需要用此参数指定验证包所需要的公钥。
		state			#默认值为present，值为absent时表示删除对应的yum原。
	示例：
		ansible GROUP1 -m yum_repository -a 'name=aliEpel description="alibaba EPEL" baseurl=https://mirrors.aliyun.com/epel/$releasever\Server/$basearch/ file=alibaba'

16，yum					#管理远程主机上的软件包
	必须参数：
		name			#指定需要管理的软件包
	其他参数：
		state			#期望软件包的状态，默认值为present表示期望已安装，其他可选值有installed、latest、absent、removed，其中installed同present，latest表示安装最新版。absent同removed，表示卸载软件包。
		disable_gpg_check	#是否禁用对rpm包的公钥gpg验证，默认值为no表示不禁用验证，yes表示禁用验证。
		enablerepo		#安装软件包时临时启用的yum源。假设所用的yum源没有启用的话，这个参数设置为yes可以临时启用这个yum源。
		disablerepo		#安装软件包时临时禁用某个yum源，适用于安装的软件包存在于多个yum源中的情况。
	示例：
		ansible GROUP1 -m yum -a 'name=nginx state=latest disable_gpg_check=yes'
		ansible GROUP1 -m yum -a 'name=telnet disable_gpg_check=yes disablerepo=local'

17，setup				#获取远程主机的信息，比如主机名，ip地址，磁盘等等。我们在playbook中可以直接使用这些信息。
	示例：
		ansible GROUP1 -m setup		
		ansible GROUP1 -m setup -a 'filter=ansible_memory_mb'		#只过滤出ansible_memory_mb的信息
		ansible GROUP1 -m setup -a "filter=*mb*"					#过滤字段还可以使用通配符
	在远程主机上自定义的信息也可以被setup模块获取到，自定义信息可以放在远程主机的etc/ansible/facts.d（如果不放在该目录下，
  使用setup模块获取自定义变量信息是需要使用fact_path指定自定义变量文件的存放目录）下，以”.fact”作为自定义信息文件的后缀。自定义变量信息应该用ini或者json格式。如下例：
  	[root@test70 facts.d]# cat testinfo.fact
 [testmsg]
 msg1=This is the first custom test message
 msg2=This is the second custom test message
  使用ansible_local关键字就可以过滤出自定义变量信息：ansible test70 -m setup -a "filter=ansible_local"

18，debug				#帮助我们调试playbook，比如打印变量的值
		参数：
			msg			#指定需要打印出的信息，里面可以包含变量，比如msg: "memory information: {{ansible_memory_mb}}"
			var			#打印变量信息，比如var: testvar， testvar是上面定义的变量

19，fail      #“执行失败”模块，执行到这个模块后整个playbook就退出，终止运行。通常是满足指定条件才会退出playbook。
    参数： 
      msg     #指定退出playbook的提示
    示例：
      ---
      - hosts: test70
        remote_user: root
        tasks:
        - shell: "echo 'This is a string for testing--error'"
          register: return_value
        - fail:
            msg: "Conditions established,Interrupt running playbook"
          when: "'error' in return_value.stdout"                      #当上一个task的标准输出中包含字符串“error”时，调用fail模块，退出playbook。
                                                                       注意这里的包含判断in的用法，还可以使用not in。这里的判断语句要用引号引起来。
                                                                       ' "error" in return_value.stdout ' 也是可以的。
        - debug:
            msg: "I never execute,Because the playbook has stopped"

yaml语法：
首行以三横线”---”开始。
缩进使用空格，不能用tab。
缩进距离没有要求，同级的缩进左对齐就行。
字典的键后面带冒号，冒号后面要有一个空格。



* playbook
playbook由一个或多个play组成，一个play可以包含一个或多个task，task就是使用模块做具体的操作。一个剧本（playbook）可以有多个桥段（play），一个桥段可以任务、场景等等。
默认情况下每个play的第一个task是Gathering Facts，这个task是获取要执行这个play的所有远程主机的信息，比如主机名，ip地址，磁盘等等。这个task就是使用setup这个模块。
可以在play中使用gather_facts：no 跳过这个默认的[Gathering Facts]任务。


play的组成：
	必须项：
		hosts
		tasks
	可选项：
		remote_user
		become
		vars


task的语法：
  选项：
      ignore_errors       #是否忽略报错，值为true表示忽略报错继续执行后面的task。默认值为no表示遇到报错就停止执行，后面的task不会执行。
      failed_when         #如果后面的条件成立则将该task的执行状态设置为失败，
        示例：
            tasks:
            - shell: "echo 'This is a string for testing error'"
              register: return_value
              failed_when: ' "error" in return_value.stdout'      #如果该task的标准输出中包含字符串“error”则将该task的执行状态设置为失败，
                                                                   从而退出playbook，其实这里的task是执行成功的。

      changed_when        #后面的条件成立时，将对应任务的执行状态设置为changed。可以通过设置任务状态为changed触发handlers任务的执行。
                           把changed_when设置为false表示任务的状态不会设置为changed状态，如果任务原本的执行状态为changed也会被修改成ok。
        示例：
            - debug:
                msg: "test message"
              changed_when: 2 > 1                                                             

	模块的参数有三种写法：
tasks:
- name: make testfile
   file:
     path: /testdir/testfile
     state: touch
     mode: 0700

tasks:
- name: make testfile
   file: path=/testdir/testfile 			#一行写不完可以分成多行，但是要注意左对齐。
		      state=touch mode=0700

tasks:
- name: make testfile
   action: file path=/testdir/testfile state=touch mode=0700		#用action调用模块，这是旧的写法。
	
	task的各个属性没有顺序要求，但是严格要求缩进对齐。

handlers
	有些task之间是有关联的，比如修改了某个服务的配置文件，需要重启对应的服务才能使配置修改生效，这个两个task就是关联的，只有修改了配置文件就触发重启服务，
  如果配置文件没有变动则不重启服务。handlers就是用来满足这种需求，handlers可以说是另一种tasks，常规的task真正执行（发生了变化，返回为黄色）之后通过
  notify触发指定的handler执行。但是常规情况下并不是task一执行完触发的handler就马上执行，要等tasks列表里面所有的task执行完成后才会执行被触发的handler，
  而且handlers里面task的执行也是按顺序执行的，不是按触发先后顺序执行的。如果想要tasks下的某个task一执行完成就触发执行handlers下的handler，可以在该
  task后面加上- meta: flush_handlers 表示马上执行触发的handlers下的handler，注意- meta: flush_handlers跟该task是同级的。还可以在一个task后面触
  发一个handler组，则属于同一个handler组中的handler都会被触发，handler定义中listen字段的值一样的handler就属于同一个handler组。
	示例：
---
- hosts: GROUP1
  remote_user: root
  tasks:
  - name: task1
    file: path=/testdir/testfile
          state=touch
    notify: handler group1

- meta: flush_handlers

	      - name: task1
 	        file: path=/testdir/testfile
         	       state=touch

  handlers:
  - name: handler1
    listen: handler group1
    file: path=/testdir/ht1
          state=touch
  - name: handler2
    listen: handler group1
    file: path=/testdir/ht2
          state=touch

tags
	可以给task或者play打tag(标签)，执行playbook时可以只执行或者跳过带有指定tag的task或者paly，如果给play加tag则play下面
  的task都会继承这个tag。一个task/play可以带多个tag，执行playbook时也可以使用--tags或者--skip-tags指定一个或多
  个tag(多个tag之间用逗号分隔)。加tag的几种语法如下：

语法一：
tags:
 - testtag
 - t1
 
语法二：
tags: tag1,t1
 
语法三：
tags: ['tagtest','t2']

	几种特殊的tag
		always		#带有该tag的任务总是会执行，除非使用--skip-tags明确跳过，但是指定always跳过的话会跳过所有带有always的任务，所以给该任务另外一个tag。
		never		#
		tagged		#这不是加给任务的，只是在执行时用来指定所有有tag的任务
		untagged		#这不是加给任务的，只是在执行时用来指定所有不带tag的任务
		all			#表示所有任务会被执行，不用指定，默认情况下就是使用这个标签。
	
	示例：
		ansible-playbook --skip-tags tagged testtag.yml		#跳过所有带了tag的任务
		ansible-playbook --tags untagged testtag.yml		#执行所有没有带tag的任务

变量					#变量由字母、数字、下划线组成，需要以字母开头，不能使用ansible占用的关键字
	方法一：在playbook中定义变量
	    vars				#在playbook中可以使用vars关键字定义变量
	        vars定义变量的几种语法：
	        	语法一：
                  vars:
                     testvar1: testfile
                     testvar2: testfile2
	        	语法二：
                  vars:
                     - testvar1: testfile
                     - testvar2: testfile2
	        	语法三：
                  vars:
                     nginx:
                        conf80: /etc/nginx/conf.d/80.conf
                        conf8080: /etc/nginx/conf.d/8080.conf

	引用变量
          - name: task1
            file:
              path: /testdir/{{ testvar1 }}			#如果变量前面还有其他字符串则可以不用引号引用变量。
              state: touch

          - name: task1
            file:
              path: "{{nginx.conf80}}"			#如果变量在开头（前面没有其他字符串）则需要用引号引用，否则报错	
              state: touch
          - name: task2
            file:
              path: "{{nginx.conf8080}}"			#或者"{{nginx['conf8080’]}}”
              state: touch

          - name: task1
            file:
              path={{nginx.conf80}}				#可以用等号给模块参数赋值，这样引用变量就可以不用引号。
              state=touch
          - name: task2
            file:
              path={{nginx['conf8080']}}
              state=touch

		
	方法二：使用变量文件定义变量，有些场景中playbook可以公开，变量值不便公开。
		变量文件示例：		#不用vars关键字
            语法一示例：
              testvar1: testfile
              testvar2: testfile2
            语法二示例：
              - testvar1: testfile
              - testvar2: testfile2
            语法三示例：
            nginx:
              conf80: /etc/nginx/conf.d/80.conf
              conf8080: /etc/nginx/conf.d/8080.conf

		使用变量文件定义的变量：
            ---
            - hosts: test70
              remote_user: root
              vars_files:						#使用var_files导入变量文件
              - /testdir/ansible/nginx_vars.yml
              tasks:
              - name: task1
                file:
                  path={{nginx.conf80}}
                  state=touch
              - name: task2
                file:
                  path={{nginx['conf8080']}}
                  state=touch

	上面两种变量定义方式可以同时使用

  使用include_vars模块加载变量文件              #通过vars_files可以加载变量文件，为什么这里
                                              又引出一个include_vars模块呢？可以看到vars_files
                                              是play级别的，也就是运行play下的tasks之前加载变量文件，
                                              如果play在执行过程中变量文件有更新则不能实时更新。
                                              而include_vars模块是在tasks下的，可以动态加载变量文件。
                                              include_vars模块会将加载的变量文件列表写到自己的返回值中，
                                              这个返回值的关键字为"ansible_included_var_files"，可以
                                              通过注册变量的方式访问到被加载的变量文件列表。
      示例1：
            tasks:
            #这里使用file选项指定加载的变量文件，其实可以不使用这个选项直接加载 - include_vars: "/testdir/ansible/testfile"
            - include_vars:                 
                file: /testdir/ansible/testfile
                #将变量文件中所有的变量赋值给trans_var这个变量，比如变量文件中有变量a=1，b=2
                #则可以通过{{ trans_var.a }}、{{ trans_var.b }}访问文件中的变量。
                name: trans_var

      示例2: 使用dir加载目录中的所有变量文件
              - include_vars:
                  #使用dir加载指定目录中的所有变量文件，默认会加载该目录下
                  #所有子目录下的变量文件。默认情况下该目录及子目录下的所有文件
                  #必须以'.yaml'、'.yml'、'.json'为后缀，如果该目录中有
                  #其他后缀的文件，执行playbook时会报错。dir参数与file参数不能同时使用
                  dir: /testdir/ansible/test/

                  #通过extensions设定合法的变量文件名后缀，默认值为[yaml,yml,json] 
                  extensions: [yaml,yml,json,varfile] 

                  #通过depth参数指定递归加载的深度。默认值为0，表示递归到最底层，depth=1表示递归深度为1
                  depth: 1

                  #使用files_matching参数指定要加载的变量文件，这里可以使用正则表达式，不匹配的变量文件不会加载。
                  #还可以使用ignore_files排除变量文件。比如ignore_files: ["^var_.*", varintest.yaml]
                  #这里表示只加载文件名以var_开头的变量文件。
                  file_matching: "^var_.*"
                  name: trans_var
              - debug:
                  msg: "{{trans_var}}"
    

* 注册变量          #一个task执行后会有一些“返回值”，只是默认情况下，这些“返回值”并不会显示。
                    将一个task的“返回值”赋值给一个变量就称为注册变量。使用注册变量不仅可以
                    显示task的执行返回值，还可以根据返回值决定之后的一些动作。注册变量使用
                    register进行定义。
    示例：
        ---
        - hosts: test70
          remote_user: root
          tasks:
          - name: test shell
            shell: "echo test > /var/testshellfile"
            register: testvar                       #这里使用register将这个task的返
                                                     回值赋值给testvar这个变量。
          - name: shell module return values
            debug:
              var: testvar                          #这里使用debug模块将上面定义的注册
                                                     变量打印出来。testvar变量是一个json对象。

        返回结果如下：
           TASK [shell module return values] **********************************************************************
            ok: [test70] => {
                "testvar": {
                    "changed": true, 
                    "cmd": "echo test > /var/testshellfile", 
                    "delta": "0:00:00.003808", 
                    "end": "2018-06-17 20:42:37.675382", 
                    "failed": false, 
                    "rc": 0, 
                    "start": "2018-06-17 20:42:37.671574", 
                    "stderr": "", 
                    "stderr_lines": [], 
                    "stdout": "", 
                    "stdout_lines": []
                }
            }                                          
            如果只想取这个json对象里面的某个字段的值，可以使用以下方法：
                语法一
                  - name: shell module return values
                    debug:
                      msg: "{{testvar.cmd}}"
                语法二
                  - name: shell module return values
                    debug:
                      msg: "{{testvar['cmd']}}"

    在主机清单（Inventory）中定义变量,可以使用ini或json两种方式定义。
        给单个主机配置变量          #直接在主机后面定义变量即可。
            test70 ansible_host=10.1.1.70 testhostvar=test70_host_var
        给主机组定义变量        
            [testB:vars]
            test_group_var1='group var test'
            test_group_var2='group var test2'
        json方式
            all:
             children:
               testB:
                 hosts:
                   test70:
                     ansible_host: 10.1.1.70
                     ansible_port: 22
                     testhostvar: test70_host_var
                     testhostvar3:
                       thv31: 3.1
                       thv32: 3.2
                   test71:
                     ansible_host: 10.1.1.71
                     ansible_port: 22
                 vars:
                   test_group_var1: 'group var test1'
                   test_group_var2: 'group var test2'
    通过set_fact定义变量        #set_fact是一个模块，通过这个模块可以给这个play的hosts里的主机定义变量，
                                默认情况下每个play执行时都会执行”[Gathering Facts]”这个task来获取主机的相关信息，
                                我们称这信息为facts信息，我们可以在play中直接使用facts信息，而通过set_fact定义的变量
                                就相当于facts信息。通过set_fact定义的变量可以跨play使用，而在play中用vars定义的变量
                                是不能跨play引用的。注意通过set_fact定义的变量是定义给主机的，跨play作用同一台主机时
                                才能使用set_fact定的变量。
        示例：
            ---
            - hosts: test70
              remote_user: root
              vars:
                testvar1: tv1
              tasks:
              - set_fact:
                  testvar2: tv2
              - debug:
                  msg: "{{testvar1}} ----- {{testvar2}}"

            - hosts: test70
              remote_user: root
              tasks:
              - name: other play get testvar2
                debug:
                  msg: "{{testvar2}}"
              - name: other play get testvar1
                debug:
                  msg: "{{testvar1}}"       #这里引用上一个play用vars定义的变量会报错。
        
playbook的交互       #playbook在执行过程中可以与用户进行交互，获取用户的输入，
                     然后根据用户的输入决定下一步的动作。可以使用vars_prompt模块
                     来接收用户的输入。
        playbook交互示例：
        ---
        - hosts: test70
          remote_user: root
          vars_prompt:                      #使用vars_prompt接收用户输入
            - name: "user_name"             #用户输入的内容会保存到name定义的变量名中
              prompt: "Enter user name"     #输入提示
              private: no                   #（可选）输入是否可见，
                                             值为no时表示用户可以看到自己输入了什么内容。
                                             默认值为yes，表示用户看不到自己输入了什么。
              default："andy"               #（可选）默认值，如果用户没有输入就用这个默认值。
            - name: "user_password"
              prompt: "Enter user password"
              encrypt: "sha512_crypt"       #（可选）用户输入的明文密码经过哈希处理再传给user_password变量。
                                             这里哈希加密依赖python的passlib库。
              confirm: yes                  #（可选）重复确认，两次的输入完全相同才设置成功。
          tasks:
           - name: create user
             user:
              name: "{{user_name}}"
              password: "{{user_password}}"

* 通过命令行传入变量        #通过命令行传入的变量优先级比playbook和变量文件的高。
                         如果playbook中引用了一个没有定义的变量执行会报错，可以
                         在执行playbook是临时传入变量就可以正常执行。ad-hoc和playbook
                         方式都可以在命令行通过--extra-vars参数（或简写-e）传入变量。
                         不仅可以传入变量，还可以传变量文件。

    示例：  
        ansible-playbook cmdvar.yml -e 'pass_var="test" pass_var1="test1"'      #多个变量以空格分隔。
        ansible test70 -e "testvar=test" -m shell -a "echo {{testvar}}"   
        ansible-playbook cmdvar.yml -e '{"testvar":"test","testvar1":"test1"}'  #以json格式传入变量
        ansible-playbook cmdvar.yml -e '{"countlist":["one","two","three","four"]}'    #这种方式如果想获取“one”，
                                                                                        有两种方法：{{countlist[0]}} 或者 {{countlist.0}}  
        ansible-playbook cmdvar.yml -e "@/testdir/ansible/testvar"          #变量文件以@开头

* ansible内置变量
    ansible_version         #这个变量表示ansible的版本，可以直接使用
    hostvars                #可以通过这个内置变量访问其他主机的变量（包括facts信息，主机清单里定义的变量，或者set_fact设置的变量）
                             针对A主机执行playbook时，要使用B主机的facts信息，则必须提前收集B主机的facts信息（B主机执行过”[Gathering Facts]”）
        示例：  
              ---
              - name: "play 1: Gather facts of test71"
                hosts: test71
                remote_user: root               #这个play没有定义task，但是会执行默认的[Gathering Facts]任务，
                                                 也就是会收集test71的facts信息，后面的play会用到。
              
              - name: "play 2: Get facts of test71 when operating on test70"
                hosts: test70
                remote_user: root
                tasks:
                - debug:
                    msg: "{{hostvars['test71'].ansible_ens35.ipv4}}"    #针对test70执行play，引用test71的facts信息。
                                                                         另一种引用方法："{{hostvars.test71.ansible_ens35.ipv4}}"                  
              #除了facts信息，还能引用其他主机的注册变量
              ---
              - hosts: test71
                remote_user: root
                gather_facts: no
                tasks:
                - shell: "echo register_var_in_play1"
                  register: shellreturn
              
              - hosts: test70
                remote_user: root
                gather_facts: no
                tasks:
                - debug:
                    msg: "{{hostvars.test71.shellreturn.stdout}}"

    inventory_hostname          #这个变量表示当前被执行主机在主机清单中定义的主机别名，如果主机清单中没有定义主机别名，则值为ip地址。
    inventory_hostname_short    #也是表示主机清单中的定义的主机别忙，只不过取简短别名（第一个点号前面的），比如test70.yh.com取test70。
    play_host                   #当前play所操作的所有主机的主机名列表。
    groups                      #这个变量包含了主机清单里面的所有主机，主机与分组的关系，没有分组的主机放在ungrouped下面。
    group_names                 #这个变量表示当前主机所属的所有组，如果当前主机不属于任何组就是ungrouped组。
    inventory_dir               #这个变量表示主机清单的存放目录。

循环
    这里有两个关键字with_items和item，可以将一个列表赋值给with_items，然后item遍历with_items列表中的各个元素。
        示例1：
              tasks:
              - debug:
                  msg: "{{item}}"                       #item遍历with_items列表中的所有元素
                with_items: "{{groups.ungrouped}}"      #这里把主机清单中不属于任何组的主机列表赋值给with_items
        示例2:
              tasks:
              - debug:
                  msg: "{{item}}"
                with_items:                             #可以直接定义一个列表赋值给with_items。with_items: [ 1,2,3 ]这种形式也可。
                - 1
                - 2
                - 3
        示例3:
              tasks:
              - debug:
                  msg: "{{item.test1}}"
                with_items:                             
                - { test1: a, test2: b }
                - { test1: c, test2: d }
        示例4:
              tasks:
              - shell: "{{item}}"
                with_items:
                - "ls /opt"
                - "ls /home"
                register: returnvalue                   #这个play会循环执行两次shell模块，然后执行返回值会赋给注册变量returnvalue
                                                         后面的执行返回不会覆盖前面的执行返回，每次执行返回都会追加到returnvalue对象的results属性里面，
                                                         results是一个列表。
              - debug:
                  msg: "{{item.stdout}}"                
                with_items: "{{returnvalue.results}}"    #将上个task的注册变量returnvalue对象的results字段的值赋值给with_items。

条件判断        #可以设置条件，当判断条件为true时才执行相应的task。使用关键字when设置条件。when引用变量时不需要用两个大括号"{{ }}"引用变量
      条件判断运算符：
          比较运算符：    ==、!=、>、<、>=、<=
          逻辑运算符：    and、or、not、()            #not表示取反，（）将多条条件组合在一起。
      示例1：
          ---
          - hosts: test70
            remote_user: root
            tasks:
            - debug:
                msg: "System release is centos6 or centos7"
              when: ansible_distribution == "CentOS" and              
                    (ansible_distribution_major_version == "6" or ansible_distribution_major_version == "7")   
      
      示例2:
          ---
          - hosts: test70
            remote_user: root
            tasks:
            - debug:
                msg: "System release is centos7"
              when:                                       #这里when使用列表的形式设置多个条件，列表里面的条件都满足时才执行该task。
              - ansible_distribution == "CentOS"
              - ansible_distribution_major_version == "7"

任务块（block）的用法           #可以将多个任务组成一个任务块。比如当满足某个条件时要执行多个任务则可以将多个任务放在一个任务块里面。
                              block另一个功能就是“错误处理”，与rescue、always（可选）配合使用。这个功能是什么意思呢？意思是当
                              block块中任意一个task执行错误时，block中剩下的任务就不会继续执行了，而是执行rescue下面的任务（可以包含多个任务），
                              如果block块中的任务都执行成功则不会执行rescue里面的任务。不管block、rescue中的任务是否执行成功，always里面的任务
                              都会执行。
        示例1:
            ---
            - hosts: test70
              remote_user: root
              tasks:
              - debug:
                  msg: "task1 not in block"
              - block:                            #这里将两个任务包含在block任务块里面，当when的条件满足时，block任务块里面的任务都会执行。
                  - debug:
                      msg: "task2 in block1"
                  - debug:
                      msg: "task3 in block1"
                when: 2 > 1

        示例2:
            ---
            - hosts: test70
              remote_user: root
              tasks:
              - block:                                                    #block中任一任务执行错误后，剩下的任务不会再执行，而是执行rescue里面的任务。
                  - debug:
                      msg: 'I execute normally'
                  - command: /bin/false
                  - debug:
                      msg: 'I never execute, due to the above task failing'
                rescue:                                                     #rescue里面的任务执行报错后，剩下的任务也不会被执行，继而执行always下面的任务。
                  - debug:
                      msg: 'I caught an error'
                  - command: /bin/false
                  - debug:
                      msg: 'I also never execute'
                always:
                  - debug:
                      msg: "This always executes"

过滤器              #过滤器是一种数据处理的工具。比如把一个字符串"abcde"给到upper过滤器就会把原字符串变都成大写"ABCDE"，
                    把一个字符串"ABCDE"给到lower过滤器就会把原字符串都变成小写"abcde"。
    字符串相关的过滤器：
          ---
          - hosts: test70
            remote_user: root
            vars:
              testvar: "abc123ABC 666"
              testvar1: "  abc  "
              testvar2: '123456789'
              testvar3: "1a2b,@#$%^&"
            tasks:
            - debug:
                #将字符串转换成纯大写
                msg: "{{ testvar | upper }}"            #通过管道符将变量传递给过滤器
            - debug:
                #将字符串转换成纯小写
                msg: "{{ testvar | lower }}"
            - debug:
                #将字符串变成首字母大写,之后所有字母纯小写
                msg: "{{ testvar | capitalize }}"
            - debug:
                #将字符串反转
                msg: "{{ testvar | reverse }}"
            - debug:
                #返回字符串的第一个字符
                msg: "{{ testvar | first }}"
            - debug:
                #返回字符串的最后一个字符
                msg: "{{ testvar | last }}"
            - debug:
                #将字符串开头和结尾的空格去除
                msg: "{{ testvar1 | trim }}"
            - debug:
                #将字符串放在中间，并且设置字符串的长度为30，字符串两边用空格补齐30位长
                msg: "{{ testvar1 | center(width=30) }}"
            - debug:
                #返回字符串长度,length与count等效,可以写为count
                msg: "{{ testvar2 | length }}"
            - debug:
                #将字符串转换成列表，每个字符作为一个元素
                msg: "{{ testvar3 | list }}"
            - debug:
                #将字符串转换成列表，每个字符作为一个元素，并且随机打乱顺序
                #shuffle的字面意思为洗牌
                msg: "{{ testvar3 | shuffle }}"
            - debug:
                #将字符串转换成列表，每个字符作为一个元素，并且随机打乱顺序
                #在随机打乱顺序时，将ansible_date_time.epoch的值设置为随机种子
                #也可以使用其他值作为随机种子，ansible_date_time.epoch是facts信息
                msg: "{{ testvar3 | shuffle(seed=(ansible_date_time.epoch)) }}"

    数字操作相关的过滤器：
          ---
          - hosts: test70
            remote_user: root
            vars:
              testvar4: -1
            tasks:
            - debug:
                #将对应的值转换成int类型
                #ansible中，字符串和整形不能直接计算，比如{{ 8+'8' }}会报错
                #所以，我们可以把一个值为数字的字符串转换成整形后再做计算
                msg: "{{ 8+('8' | int) }}"
            - debug:
                #将对应的值转换成int类型,如果无法转换,默认返回0
                #使用int(default=6)或者int(6)时，如果无法转换则返回指定值6
                msg: "{{ 'a' | int(default=6) }}"
            - debug:
                #将对应的值转换成浮点型，如果无法转换，默认返回'0.0'
                msg: "{{ '8' | float }}"
            - debug:
                #当对应的值无法被转换成浮点型时，则返回指定值’8.8‘
                msg: "{{ 'a' | float(8.88) }}"
            - debug:
                #获取对应数值的绝对值
                msg: "{{ testvar4 | abs }}"
            - debug:
                #四舍五入
                msg: "{{ 12.5 | round }}"
            - debug:
                #取小数点后五位
                msg: "{{ 3.1415926 | round(5) }}"
            - debug:
                #从0到100中随机返回一个随机数
                msg: "{{ 100 | random }}"
            - debug:
                #从5到10中随机返回一个随机数
                msg: "{{ 10 | random(start=5) }}"
            - debug:
                #从5到15中随机返回一个随机数,步长为3
                #步长为3的意思是返回的随机数只有可能是5、8、11、14中的一个
                msg: "{{ 15 | random(start=5,step=3) }}"
            - debug:
                #从0到15中随机返回一个随机数,这个随机数是5的倍数
                msg: "{{ 15 | random(step=5) }}"
            - debug:
                #从0到15中随机返回一个随机数，并将ansible_date_time.epoch的值设置为随机种子
                #也可以使用其他值作为随机种子，ansible_date_time.epoch是facts信息
                #seed参数从ansible2.3版本开始可用
                msg: "{{ 15 | random(seed=(ansible_date_time.epoch)) }}"

      列表操作相关的过滤器:
          ---
          - hosts: test70
            remote_user: root
            vars:
              testvar7: [22,18,5,33,27,30]
              testvar8: [1,[7,2,[15,9]],3,5]
              testvar9: [1,'b',5]
              testvar10: [1,'A','b',['QQ','wechat'],'CdEf']
              testvar11: ['abc',1,3,'a',3,'1','abc']
              testvar12: ['abc',2,'a','b','a']
            tasks:
            - debug:
                #返回列表长度,length与count等效,可以写为count
                msg: "{{ testvar7 | length }}"
            - debug:
                #返回列表中的第一个值
                msg: "{{ testvar7 | first }}"
            - debug:
                #返回列表中的最后一个值
                msg: "{{ testvar7 | last }}"
            - debug:
                #返回列表中最小的值
                msg: "{{ testvar7 | min }}"
            - debug:
                #返回列表中最大的值
                msg: "{{ testvar7 | max }}"
            - debug:
                #将列表升序排序输出
                msg: "{{ testvar7 | sort }}"
            - debug:
                #将列表降序排序输出
                msg: "{{ testvar7 | sort(reverse=true) }}"
            - debug:
                #返回纯数字非嵌套列表中所有数字的和
                msg: "{{ testvar7 | sum }}"
            - debug:
                #如果列表中包含列表，那么使用flatten可以'拉平'嵌套的列表
                #2.5版本中可用,执行如下示例后查看效果
                msg: "{{ testvar8 | flatten }}"
            - debug:
                #如果列表中嵌套了列表，那么将第1层的嵌套列表‘拉平’
                #2.5版本中可用,执行如下示例后查看效果
                msg: "{{ testvar8 | flatten(levels=1) }}"
            - debug:
                #过滤器都是可以自由结合使用的，就好像linux命令中的管道符一样
                #如下，取出嵌套列表中的最大值
                msg: "{{ testvar8 | flatten | max }}"
            - debug:
                #将列表中的元素合并成一个字符串
                msg: "{{ testvar9 | join }}"
            - debug:
                #将列表中的元素合并成一个字符串,每个元素之间用指定的字符隔开
                msg: "{{ testvar9 | join(' , ') }}"
            - debug:
                #从列表中随机返回一个元素
                #对列表使用random过滤器时，不能使用start和step参数
                msg: "{{ testvar9 | random }}"
            - debug:
                #从列表中随机返回一个元素,并将ansible_date_time.epoch的值设置为随机种子
                #seed参数从ansible2.3版本开始可用
                msg: "{{ testvar9 | random(seed=(ansible_date_time.epoch)) }}"
            - debug:
                #随机打乱顺序列表中元素的顺序
                #shuffle的字面意思为洗牌
                msg: "{{ testvar9 | shuffle }}"
            - debug:
                #随机打乱顺序列表中元素的顺序
                #在随机打乱顺序时，将ansible_date_time.epoch的值设置为随机种子
                #seed参数从ansible2.3版本开始可用
                msg: "{{ testvar9 | shuffle(seed=(ansible_date_time.epoch)) }}"
            - debug:
                #将列表中的每个元素变成纯大写
                msg: "{{ testvar10 | upper }}"
            - debug:
                #将列表中的每个元素变成纯小写
                msg: "{{ testvar10 | lower }}"
            - debug:
                #去掉列表中重复的元素，重复的元素只留下一个
                msg: "{{ testvar11 | unique }}"
            - debug:
                #将两个列表合并，重复的元素只留下一个
                #也就是求两个列表的并集
                msg: "{{ testvar11 | union(testvar12) }}"
            - debug:
                #取出两个列表的交集，重复的元素只留下一个
                msg: "{{ testvar11 | intersect(testvar12) }}"
            - debug:
                #取出存在于testvar11列表中,但是不存在于testvar12列表中的元素
                #去重后重复的元素只留下一个
                #换句话说就是:两个列表的交集在列表1中的补集
                msg: "{{ testvar11 | difference(testvar12) }}"
            - debug:
                #取出两个列表中各自独有的元素,重复的元素只留下一个
                #即去除两个列表的交集，剩余的元素
                msg: "{{ testvar11 | symmetric_difference(testvar12) }}"
              
      变量未定义时的相关操作过滤器：
          ---
          - hosts: test70
            remote_user: root
            gather_facts: no
            vars:
              testvar6: ''
            tasks:
            - debug:
                #如果变量没有定义，则临时返回一个指定的默认值
                #注：如果定义了变量，变量值为空字符串，则会输出空字符
                #default过滤器的别名是d
                msg: "{{ testvar5 | default('zsythink') }}"
            - debug:
                #如果变量的值是一个空字符串或者变量没有定义，则临时返回一个指定的默认值
                msg: "{{ testvar6 | default('zsythink',boolean=true) }}"
            - debug:
                #如果对应的变量未定义,则报出“Mandatory variable not defined.”错误，而不是报出默认错误
                msg: "{{ testvar5 | mandatory }}"

      示例：
        - hosts: test70
          remote_user: root
          gather_facts: no
          vars:
            paths:
              - path: /tmp/test
                mode: '0444'
              - path: /tmp/foo
              - path: /tmp/bar
          tasks:
            #如果item有mode属性就使用，如果item没有mode属性就省略。这里omit就是省略的意思。
          - file: dest={{item.path}} state=touch mode={{item.mode | default(omit)}}         
            with_items: "{{ paths }}"

1. ansible-playbook --syntax-check test.yaml        #检查yaml文件的语法是否正确
2. ansible-playbook --check test.yml		        	#模拟执行，不会真正执行。

4. ansible-playbook --list-task test.yaml  			#列出tasks任务

5. ansible-playbook  --list-hosts test.yaml  		#列出待执行的主机

6. ansible-playbook  --start-at-task=‘Copy Nginx.conf’  test.yaml  		#从指定的task开始执行
7. ansible-playbook --list-tags testhttpd.yml            #列出playbook中的tag
8. 


